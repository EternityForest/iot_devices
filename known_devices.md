# Known Device Plugins

All devices shown, some config params may be unlisted.
This documentation is autogenerated with iot_devices_scan.py

## ConfigurableAlarm

Triggers an alarm when one of it's data points goes True, if the framework supports the alarms.

```python
from iot_devices.host import create_device
from iot_devices.devices.alarm import ConfigurableAlarm

dev = create_device(ConfigurableAlarm, "name", {
    'device.alarm_name': 'alarm',
    'device.priority': 'warning',
    'device.auto_acknowledge': 'no'
})



print(dev.datapoints['trigger'])
# >>> None

# trigger is writable
# dev.set_data_point('trigger', <your value> )

```

## DemoDevice

Just a demo device that makes pseudorandom numbers on request

```python
from iot_devices.host import create_device
from iot_devices.devices.demo import DemoDevice

dev = create_device(DemoDevice, "name", {
    'device.fixed_number_multiplier': '1'
})



print(dev.datapoints['random'])
# >>> 0.6442211803589764

# random is writable
# dev.set_data_point('random', <your value> )

print(dev.datapoints['dyn_random'])
# >>> None

# dyn_random is writable
# dev.set_data_point('dyn_random', <your value> )

# bool
print(dev.datapoints['useless_toggle'])
# >>> None

# useless_toggle is writable
# dev.set_data_point('useless_toggle', <your value> )

# trigger
print(dev.datapoints['do_nothing'])
# >>> None

# do_nothing is writable
# dev.set_data_point('do_nothing', <your value> )

print(dev.datapoints['read_only'])
# >>> 0.9917534168707931

```

## ESPHomeDevice

Represents one single ESPHome device.  Cannot flash or update the ESP, use the dashboard tool for that.

```python
from iot_devices.host import create_device
from iot_devices.devices.ESPHomePlugin import ESPHomeDevice

dev = create_device(ESPHomeDevice, "name", {
    'device.apikey': '',
    'device.hostname': ''
})



# bool
print(dev.datapoints['native_api_connected'])
# >>> None

```

## GPIOInput

Represents a hardware input pin. Supports RasPi and mocked fake pins.

```python
from iot_devices.host import create_device
from iot_devices.devices.GPIODevice import GPIOInput

dev = create_device(GPIOInput, "name", {
    'device.active_high': 'true',
    'device.pull_up': 'false',
    'device.pull_down': 'false',
    'device.pin': 'MOCK1',
    'device.debounce_time_ms': '0'
})



# boolean
print(dev.datapoints['value'])
# >>> 0

```

## GPIOOutput

Represents a hardware output pin, possibly with PWM.  Supports RasPi and mocked fake pins.

```python
from iot_devices.host import create_device
from iot_devices.devices.GPIODevice import GPIOOutput

dev = create_device(GPIOOutput, "name", {
    'device.active_high': '1',
    'device.initial_value': '0',
    'device.pin': 'MOCK1',
    'device.pwm_frequency': '100'
})



# boolean
print(dev.datapoints['value'])
# >>> 0.0

# value is writable
# dev.set_data_point('value', <your value> )

```

## RTL433Client

Listen to messages from rtl_433 and decode them into things like weather station data

```python
from iot_devices.host import create_device
from iot_devices.devices.RTL433 import RTL433Client

dev = create_device(RTL433Client, "name", {
    'device.interval': '300',
    'device.id': '',
    'device.model': '',
    'device.server': 'localhost',
    'device.port': '1883',
    'device.password': '',
    'device.mqttTopic': 'home/rtl_433'
})



# -75 if recetly seen, otherwise -180, we don't have real RSSI data
print(dev.datapoints['rssi'])
# >>> None

print(dev.datapoints['mqttStatus'])
# >>> 0.0

```

## RokuRemoteApp

Allow Roku ECP protocol remotes to discover this server and control a tag point.

```python
from iot_devices.host import create_device
from iot_devices.devices.RokuRemoteApp import RokuRemoteApp

dev = create_device(RokuRemoteApp, "name", {
    'device.serial': 'P0A070000007',
    'device.uuid': '218ba7aa-5a10-404e-bb73-95d644891cce',
    'device.bind': '0.0.0.0:54671'
})



# %
print(dev.datapoints['battery'])
# >>> None


```

## ServerMonitor

Check that an externeral device is still reachable and functioning.

```python
from iot_devices.host import create_device
from iot_devices.devices.servermonitor import ServerMonitor

dev = create_device(ServerMonitor, "name", {
    # Hostname or URL to ping.  If an http:// url is used, will poll with HTTP as well as ping.
    'device.target': '',
    # With HTTP URLs, expects to find string matching this regex in the returned data
    'device.expect_pattern': '',
    'device.check_interval': '300'
})



# bool
print(dev.datapoints['status'])
# >>> None


```

## WeatherClient

Get current weather info. No API key needed, uses wttr.in at the moment

```python
from iot_devices.host import create_device
from iot_devices.devices.WeatherPlugin import WeatherClient

dev = create_device(WeatherClient, "name", {
    # Values below 90 minutes are ignored
    'device.location': '90,135',
    'device.update_minutes': '180'
})



# degC
print(dev.datapoints['temperature'])
# >>> None

# %
print(dev.datapoints['humidity'])
# >>> None

# KPH
print(dev.datapoints['wind'])
# >>> None

# millibar
print(dev.datapoints['pressure'])
# >>> 1018.0

print(dev.datapoints['uv_index'])
# >>> 1.0

```

## YeelightRGB

Requires YeeLight python module. This device represents a bulb.  You may want to disable autosave on these bulbs to save wear with complex effects.

```python
from iot_devices.host import create_device
from iot_devices.devices.Yeelight import YeelightRGB

dev = create_device(YeelightRGB, "name", {



print(dev.datapoints['rssi'])
# >>> None

# bool
print(dev.datapoints['switch'])
# >>> None

# switch is writable
# dev.set_data_point('switch', <your value> )

# light_fade_duration
print(dev.datapoints['fade'])
# >>> None

# fade is writable
# dev.set_data_point('fade', <your value> )

# color
print(dev.datapoints['color'])
# >>> None

# color is writable
# dev.set_data_point('color', <your value> )

```

## YoLinkService

Access all devices on a YoLink cloud account. NOTE: YoLink has no local API yet, internet dependant.  Also note this uses the unencrypted web API

```python
from iot_devices.host import create_device
from iot_devices.devices.YoLink import YoLinkService

dev = create_device(YoLinkService, "name", {
    'device.user_id': '',
    'device.key': ''
})



# bool
print(dev.datapoints['connected'])
# >>> None

```

## Zigbee2MQTT

This makes all your ZigBee devices on an MQTT server available as data points.

```python
from iot_devices.host import create_device
from iot_devices.devices.Zigbee2MQTTPlugin import Zigbee2MQTT

dev = create_device(Zigbee2MQTT, "name", {
    'device.mqtt_server': 'localhost',
    'device.friendly_name': '__all__'
})



```